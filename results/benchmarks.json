{
    "bench_climatologies.Bench_calendar_average.time_calendar_average": {
        "code": "class Bench_calendar_average:\n    def time_calendar_average(self):\n        # hourly to daily\n        calendar_average(self.hourly, freq='day')\n\n    def setup(self):\n        self.hourly = _get_dummy_data('2020-01-01', '2021-12-31 23:00:00', 'h', 1, 1)",
        "min_run_count": 2,
        "name": "bench_climatologies.Bench_calendar_average.time_calendar_average",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2e6b7fdbfa9b22363803965c4659d024391d3047169cb5956fbf5df9528d98cd",
        "warmup_time": -1
    },
    "bench_climatologies.Bench_climate_anomaly.time_climate_anomaly": {
        "code": "class Bench_climate_anomaly:\n    def time_climate_anomaly(self):\n        # monthly anomaly\n        climate_anomaly(self.daily, 'month')\n\n    def setup(self):\n        self.daily = _get_dummy_data('2020-01-01', '2021-12-31', 'D', 1, 1)",
        "min_run_count": 2,
        "name": "bench_climatologies.Bench_climate_anomaly.time_climate_anomaly",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e7074155919de5859ee64556b2a69f99cf78232b55e308be2d40ede070f11371",
        "warmup_time": -1
    },
    "bench_climatologies.Bench_climatology_average.time_climatology_average": {
        "code": "class Bench_climatology_average:\n    def time_climatology_average(self):\n        # custom season\n        climatology_average(\n            self.monthly, freq='season', custom_seasons=['DJF', 'JJA', 'MAM', 'SON']\n        )\n\n    def setup(self):\n        self.monthly = _get_dummy_data('2020-01-01', '2021-12-01', 'MS', 1, 1)",
        "min_run_count": 2,
        "name": "bench_climatologies.Bench_climatology_average.time_climatology_average",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "79add8b79fba74c516c391e5fcbedc2c2ff68d62f471b47b0d34f1513d1d55b5",
        "warmup_time": -1
    },
    "bench_climatologies.Bench_month_to_season.time_month_to_season": {
        "code": "class Bench_month_to_season:\n    def time_month_to_season(self):\n        month_to_season(self.ds, \"JJA\")\n\n    def setup(self):\n        self.ds = get_fake_dataset(start_month=\"2000-01\", nmonths=12, nlats=3, nlons=1)",
        "min_run_count": 2,
        "name": "bench_climatologies.Bench_month_to_season.time_month_to_season",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "83fa155d938d3086b306f2f2fff4a80571c9bd63f5753ba84e1e21a1a633ef80",
        "warmup_time": -1
    },
    "bench_fourier.Bench_fourier.peakmem_band_block": {
        "code": "class Bench_fourier:\n    def peakmem_band_block(self):\n        fourier_band_block(self.t_data, self.freq, 3, 30, time_axis=0)\n\n    def setup(self):\n        self.freq = 200\n        t = np.arange(200) / self.freq\n        t = t[:, None] + t\n        t = t[:, :, None] + t\n        self.t_data = (\n            np.sin(t * tau) / 0.1\n            + np.sin(2 * t * tau) / 0.2\n            + np.sin(5 * t * tau) / 0.5\n            + np.sin(10 * t * tau)\n            + np.sin(20 * t * tau) / 2\n            + np.sin(50 * t * tau) / 5\n            + np.sin(100 * t * tau) / 10\n        )",
        "name": "bench_fourier.Bench_fourier.peakmem_band_block",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "60e2a079316683768604882fc9ff0f191f22a4cc54047ef318954d30aee1c745"
    },
    "bench_fourier.Bench_fourier.time_band_block": {
        "code": "class Bench_fourier:\n    def time_band_block(self):\n        fourier_band_block(self.t_data, self.freq, 3, 30, time_axis=0)\n\n    def setup(self):\n        self.freq = 200\n        t = np.arange(200) / self.freq\n        t = t[:, None] + t\n        t = t[:, :, None] + t\n        self.t_data = (\n            np.sin(t * tau) / 0.1\n            + np.sin(2 * t * tau) / 0.2\n            + np.sin(5 * t * tau) / 0.5\n            + np.sin(10 * t * tau)\n            + np.sin(20 * t * tau) / 2\n            + np.sin(50 * t * tau) / 5\n            + np.sin(100 * t * tau) / 10\n        )",
        "min_run_count": 2,
        "name": "bench_fourier.Bench_fourier.time_band_block",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e4879fe8c246ef21be8111a4d4289ea25b26418f03895fcbc95cf205de12e951",
        "warmup_time": -1
    },
    "bench_interpolation.Bench_interp_hybrid_to_pressure.peakmem_interp_hybrid_to_pressure": {
        "code": "class Bench_interp_hybrid_to_pressure:\n    def peakmem_interp_hybrid_to_pressure(self):\n        interp_hybrid_to_pressure(\n            self.data,\n            self.ps,\n            self._hyam,\n            self._hybm,\n            p0=self._p0,\n            new_levels=self.pres3d,\n            method=\"log\",\n        )\n\n    def setup(self):\n        # Load test data\n        try:\n            self.ds_atmos = xr.open_dataset(\n                gdf.get(\"netcdf_files/atmos.nc\"), decode_times=False\n            )\n        except Exception:\n            self.ds_atmos = xr.open_dataset(\"test/atmos.nc\", decode_times=False)\n    \n        # Set up input parameters similar to test class\n        self._hyam = self.ds_atmos.hyam\n        self._hybm = self.ds_atmos.hybm\n        self._p0 = 1000.0 * 100  # Pa\n    \n        self.data = self.ds_atmos.U[0, :, :, :]\n        self.ps = self.ds_atmos.PS[0, :, :]\n        self.pres3d = np.asarray([1000, 950, 800, 700, 600, 500, 400, 300, 200]) * 100",
        "name": "bench_interpolation.Bench_interp_hybrid_to_pressure.peakmem_interp_hybrid_to_pressure",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "beb4184b38941f397936088949dabaed43018c7743d5482eedd636fa495ebb73"
    },
    "bench_interpolation.Bench_interp_hybrid_to_pressure.time_interp_hybrid_to_pressure": {
        "code": "class Bench_interp_hybrid_to_pressure:\n    def time_interp_hybrid_to_pressure(self):\n        interp_hybrid_to_pressure(\n            self.data,\n            self.ps,\n            self._hyam,\n            self._hybm,\n            p0=self._p0,\n            new_levels=self.pres3d,\n            method=\"log\",\n        )\n\n    def setup(self):\n        # Load test data\n        try:\n            self.ds_atmos = xr.open_dataset(\n                gdf.get(\"netcdf_files/atmos.nc\"), decode_times=False\n            )\n        except Exception:\n            self.ds_atmos = xr.open_dataset(\"test/atmos.nc\", decode_times=False)\n    \n        # Set up input parameters similar to test class\n        self._hyam = self.ds_atmos.hyam\n        self._hybm = self.ds_atmos.hybm\n        self._p0 = 1000.0 * 100  # Pa\n    \n        self.data = self.ds_atmos.U[0, :, :, :]\n        self.ps = self.ds_atmos.PS[0, :, :]\n        self.pres3d = np.asarray([1000, 950, 800, 700, 600, 500, 400, 300, 200]) * 100",
        "min_run_count": 2,
        "name": "bench_interpolation.Bench_interp_hybrid_to_pressure.time_interp_hybrid_to_pressure",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "341dffd86bf83824e6014aaf35144155b7eb4c78f15024ab589efb67bed09068",
        "warmup_time": -1
    },
    "bench_interpolation.Bench_interp_hybrid_to_pressure_extrap_temp.peakmem_interp_hybrid_to_pressure_extrap_temp": {
        "code": "class Bench_interp_hybrid_to_pressure_extrap_temp:\n    def peakmem_interp_hybrid_to_pressure_extrap_temp(self):\n        interp_hybrid_to_pressure(\n            self.temp_in,\n            self.press_in,\n            self._hyam,\n            self._hybm,\n            p0=self._p0,\n            new_levels=self.new_levels,\n            method=\"linear\",\n            extrapolate=True,\n            variable='temperature',\n            t_bot=self.temp_in.isel(lev=-1, drop=True),\n            phi_sfc=self.phis,\n        )\n\n    def setup(self):\n        # Load test data\n        try:\n            self.ds_ccsm = xr.open_dataset(\n                gdf.get(\"netcdf_files/ccsm35.h0.0021-01.demo.nc\"), decode_times=False\n            )\n        except Exception:\n            self.ds_ccsm = xr.open_dataset(\n                \"test/ccsm35.h0.0021-01.demo.nc\", decode_times=False\n            )\n    \n        # Set up input parameters similar to test class\n        self.temp_in = self.ds_ccsm.T[:, :, :3, :2]\n        self.press_in = self.ds_ccsm.PS[:, :3, :2]\n        self._hyam = self.ds_ccsm.hyam\n        self._hybm = self.ds_ccsm.hybm\n        self._p0 = 1000 * 100  # reference pressure in Pa\n        self.new_levels = np.asarray([500, 925, 950, 1000])\n        self.new_levels *= 100  # new levels in Pa\n        self.phis = self.ds_ccsm.PHIS[:, :3, :2]",
        "name": "bench_interpolation.Bench_interp_hybrid_to_pressure_extrap_temp.peakmem_interp_hybrid_to_pressure_extrap_temp",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6794ebb08a5821f7370451f7567f378a44dfe8ea2e3c1a606944ab8acf313190"
    },
    "bench_interpolation.Bench_interp_hybrid_to_pressure_extrap_temp.time_interp_hybrid_to_pressure_extrap_temp": {
        "code": "class Bench_interp_hybrid_to_pressure_extrap_temp:\n    def time_interp_hybrid_to_pressure_extrap_temp(self):\n        interp_hybrid_to_pressure(\n            self.temp_in,\n            self.press_in,\n            self._hyam,\n            self._hybm,\n            p0=self._p0,\n            new_levels=self.new_levels,\n            method=\"linear\",\n            extrapolate=True,\n            variable='temperature',\n            t_bot=self.temp_in.isel(lev=-1, drop=True),\n            phi_sfc=self.phis,\n        )\n\n    def setup(self):\n        # Load test data\n        try:\n            self.ds_ccsm = xr.open_dataset(\n                gdf.get(\"netcdf_files/ccsm35.h0.0021-01.demo.nc\"), decode_times=False\n            )\n        except Exception:\n            self.ds_ccsm = xr.open_dataset(\n                \"test/ccsm35.h0.0021-01.demo.nc\", decode_times=False\n            )\n    \n        # Set up input parameters similar to test class\n        self.temp_in = self.ds_ccsm.T[:, :, :3, :2]\n        self.press_in = self.ds_ccsm.PS[:, :3, :2]\n        self._hyam = self.ds_ccsm.hyam\n        self._hybm = self.ds_ccsm.hybm\n        self._p0 = 1000 * 100  # reference pressure in Pa\n        self.new_levels = np.asarray([500, 925, 950, 1000])\n        self.new_levels *= 100  # new levels in Pa\n        self.phis = self.ds_ccsm.PHIS[:, :3, :2]",
        "min_run_count": 2,
        "name": "bench_interpolation.Bench_interp_hybrid_to_pressure_extrap_temp.time_interp_hybrid_to_pressure_extrap_temp",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ecea8f1fe7570ef05af8d219f55a3181108b3e44fb472c073977c60d5972f28c",
        "warmup_time": -1
    },
    "bench_interpolation.Bench_interp_multidim.peakmem_interp_multidim_chunk": {
        "code": "class Bench_interp_multidim:\n    def peakmem_interp_multidim_chunk(self):\n        interp_multidim(\n            self.test_input.chunk(2),\n            self.test_output.coords['lat'],\n            self.test_output.coords['lon'],\n        )\n\n    def setup(self):\n        self.test_input = xr.load_dataset(\n            gdf.get(\"netcdf_files/spherical_noise_input.nc\")\n        )['spherical_noise']\n        self.test_output = xr.load_dataset(\n            gdf.get(\"netcdf_files/spherical_noise_output.nc\")\n        )['spherical_noise']",
        "name": "bench_interpolation.Bench_interp_multidim.peakmem_interp_multidim_chunk",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "8a4c13960428f0a331f72b243e6bdd19e9ad8628aa8532237a386e4bf33cbe21"
    },
    "bench_interpolation.Bench_interp_multidim.time_interp_multidim_chunk": {
        "code": "class Bench_interp_multidim:\n    def time_interp_multidim_chunk(self):\n        interp_multidim(\n            self.test_input.chunk(2),\n            self.test_output.coords['lat'],\n            self.test_output.coords['lon'],\n        )\n\n    def setup(self):\n        self.test_input = xr.load_dataset(\n            gdf.get(\"netcdf_files/spherical_noise_input.nc\")\n        )['spherical_noise']\n        self.test_output = xr.load_dataset(\n            gdf.get(\"netcdf_files/spherical_noise_output.nc\")\n        )['spherical_noise']",
        "min_run_count": 2,
        "name": "bench_interpolation.Bench_interp_multidim.time_interp_multidim_chunk",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b48f5a7600d5491fc92f120637ff7d2b551815440c821f639195892b60c74ee7",
        "warmup_time": -1
    },
    "bench_interpolation.Bench_interp_sigma_to_hybrid.time_interp_sigma_to_hybrid_1d": {
        "code": "class Bench_interp_sigma_to_hybrid:\n    def time_interp_sigma_to_hybrid_1d(self):\n        interp_sigma_to_hybrid(\n            self.u[:, 0, 0],\n            self.sigma,\n            self.ps[0, 0],\n            self.hyam,\n            self.hybm,\n            p0=self._p0,\n            method=\"linear\",\n        )\n\n    def setup(self):\n        # Open the netCDF data file \"u.89335.1.nc\" and read in input data\n        try:\n            ds_u = xr.open_dataset(\n                gdf.get(\"netcdf_files/u.89335.1_subset_time361.nc\"), decode_times=False\n            )\n        except Exception:\n            ds_u = xr.open_dataset(\n                \"test/u.89335.1_subset_time361.nc\", decode_times=False\n            )\n    \n        try:\n            ds_ps = xr.open_dataset(\n                gdf.get(\"netcdf_files/ps.89335.1.nc\"), decode_times=False\n            )\n        except Exception:\n            ds_ps = xr.open_dataset(\"test/ps.89335.1.nc\", decode_times=False)\n    \n        self.hyam = xr.DataArray([0.0108093, 0.0130731, 0.03255911, 0.0639471])\n        self.hybm = xr.DataArray([0.0108093, 0.0173664, 0.06069280, 0.1158237])\n    \n        self.u = ds_u.u[:, 0:3, 0:2]\n        self.ps = ds_ps.ps[361, 0:3, 0:2] * 100  # Pa\n        self._p0 = 1000.0 * 100  # Pa\n        self.sigma = ds_ps.sigma",
        "min_run_count": 2,
        "name": "bench_interpolation.Bench_interp_sigma_to_hybrid.time_interp_sigma_to_hybrid_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6288b9b92c396617c64a5dfb06e83e8df9386aa7213d9d947dc4157c2d6794a7",
        "warmup_time": -1
    },
    "bench_interpolation.Bench_interp_sigma_to_hybrid.time_interp_sigma_to_hybrid_3d": {
        "code": "class Bench_interp_sigma_to_hybrid:\n    def time_interp_sigma_to_hybrid_3d(self):\n        interp_sigma_to_hybrid(\n            self.u,\n            self.sigma,\n            self.ps,\n            self.hyam,\n            self.hybm,\n            p0=self._p0,\n            method=\"linear\",\n        )\n\n    def setup(self):\n        # Open the netCDF data file \"u.89335.1.nc\" and read in input data\n        try:\n            ds_u = xr.open_dataset(\n                gdf.get(\"netcdf_files/u.89335.1_subset_time361.nc\"), decode_times=False\n            )\n        except Exception:\n            ds_u = xr.open_dataset(\n                \"test/u.89335.1_subset_time361.nc\", decode_times=False\n            )\n    \n        try:\n            ds_ps = xr.open_dataset(\n                gdf.get(\"netcdf_files/ps.89335.1.nc\"), decode_times=False\n            )\n        except Exception:\n            ds_ps = xr.open_dataset(\"test/ps.89335.1.nc\", decode_times=False)\n    \n        self.hyam = xr.DataArray([0.0108093, 0.0130731, 0.03255911, 0.0639471])\n        self.hybm = xr.DataArray([0.0108093, 0.0173664, 0.06069280, 0.1158237])\n    \n        self.u = ds_u.u[:, 0:3, 0:2]\n        self.ps = ds_ps.ps[361, 0:3, 0:2] * 100  # Pa\n        self._p0 = 1000.0 * 100  # Pa\n        self.sigma = ds_ps.sigma",
        "min_run_count": 2,
        "name": "bench_interpolation.Bench_interp_sigma_to_hybrid.time_interp_sigma_to_hybrid_3d",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7ad68ee715d277c269bfa1715f13a853680f0ff34a926acc182e6cf95396a41c",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_actual_saturation_vapor_pressure.time_actual_saturation_vapor_pressure": {
        "code": "class Bench_actual_saturation_vapor_pressure:\n    def time_actual_saturation_vapor_pressure(self):\n        actual_saturation_vapor_pressure(self.temp, tfill=1.0000000e20)\n\n    def setup(self):\n        self.temp = np.arange(1, 101, 1)",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_actual_saturation_vapor_pressure.time_actual_saturation_vapor_pressure",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "dadebe7f3314e3dcfba2d8c8506aff1e5f77b424d122c608dc666fefe601d207",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_delta_pressure.time_delta_pressure": {
        "code": "class Bench_delta_pressure:\n    def time_delta_pressure(self):\n        delta_pressure(self.pressure_lev, self.surface_pressure_scalar)\n\n    def setup(self):\n        self.pressure_lev = np.array([1, 5, 100, 1000], dtype=np.float64)\n        self.surface_pressure_scalar = 1018.0",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_delta_pressure.time_delta_pressure",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "afee1296d27ebefa412ce19c19b1fef4aa4e72e25d7b12e2f5ed511e6a208dd1",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_dewtemp.time_dewtemp": {
        "code": "class Bench_dewtemp:\n    def time_dewtemp(self):\n        xr.DataArray(self.rh_def)\n\n    def setup(self):\n        # fmt: off\n        self.rh_def = [75.0, 60.0, 61.1, 76.7, 90.5, 89.8, 78.3, 76.5, 46.0, 55.0, 63.8, 53.2, 42.9, 41.7, 51.0, 70.6, 50.0, 50.0]\n        # fmt: on",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_dewtemp.time_dewtemp",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "48011b7369bbddbc495ec2a2a047744261a4f7a17fb339d86f5869e4ee2ef11a",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_heat_index.time_heat_index": {
        "code": "class Bench_heat_index:\n    def time_heat_index(self):\n        heat_index(self.t, self.rh, True)\n\n    def setup(self):\n        self.t = np.array([70, 75, 80, 85, 90, 95, 100, 105, 110, 115])\n        self.rh = np.array([10, 75, 15, 80, 65, 25, 30, 40, 50, 5])",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_heat_index.time_heat_index",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "97f901f8dc546422188de414bc13a38d88a48f419a7e88ce5884f452dc3a1078",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_max_daylight.time_max_daylight": {
        "code": "class Bench_max_daylight:\n    def time_max_daylight(self):\n        max_daylight(self.jday, self.lat)\n\n    def setup(self):\n        self.jday = np.linspace(1, 365, num=365)\n        self.lat = np.linspace(-66, 66, num=133)",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_max_daylight.time_max_daylight",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a620b9fb1c9ab80c3c604b31cb63f0131360bfeba33a7cf8ca7840898b89e718",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_psychrometric_constant.time_psychrometric_constant": {
        "code": "class Bench_psychrometric_constant:\n    def time_psychrometric_constant(self):\n        psychrometric_constant(self.pressure)\n\n    def setup(self):\n        self.pressure = np.arange(1, 101, 1)",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_psychrometric_constant.time_psychrometric_constant",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f8d4c9fd92db24890de102f93fe9e52872a37100c94b2c55280ccd716269cd44",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_relhum.time_relhum": {
        "code": "class Bench_relhum:\n    def time_relhum(self):\n        relhum(self.t_def, self.q_def, self.p_def)\n\n    def setup(self):\n        # fmt: off\n        self.p_def = [\n            100800, 100000, 95000, 90000, 85000, 80000, 75000, 70000, 65000, 60000, 55000, 50000, 45000, 40000, 35000, 30000,\n            25000, 20000, 17500, 15000, 12500, 10000, 8000, 7000, 6000, 5000, 4000, 3000, 2500, 2000\n        ]\n    \n        self.t_def = [\n            302.45, 301.25, 296.65, 294.05, 291.55, 289.05, 286.25, 283.25, 279.85, 276.25, 272.65, 268.65, 264.15, 258.35, 251.65,\n            243.45, 233.15, 220.75, 213.95, 206.65, 199.05, 194.65, 197.15, 201.55, 206.45, 211.85, 216.85, 221.45, 222.45, 225.65\n        ]\n    \n        self.q_def = [\n            0.02038, 0.01903, 0.01614, 0.01371, 0.01156, 0.0098, 0.00833, 0.00675, 0.00606, 0.00507, 0.00388, 0.00329, 0.00239,\n            0.0017, 0.001, 0.0006, 0.0002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ]\n        # fmt: on",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_relhum.time_relhum",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "12dabc5f49074cc7346e68ff3296a1196210b9f35df9a3877dc544375fadc7b7",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_saturation_vapor_pressure.time_saturation_vapor_pressure": {
        "code": "class Bench_saturation_vapor_pressure:\n    def time_saturation_vapor_pressure(self):\n        saturation_vapor_pressure(self.temp, tfill=1.0000000e20)\n\n    def setup(self):\n        self.temp = np.arange(1, 101, 1)",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_saturation_vapor_pressure.time_saturation_vapor_pressure",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "93fa3cacb15c9cd219a04021a2e31a23b51c1d5409784c00743745faf1ea82b1",
        "warmup_time": -1
    },
    "bench_meteorology.Bench_saturation_vapor_pressure_slope.time_saturation_vapor_pressure_slope": {
        "code": "class Bench_saturation_vapor_pressure_slope:\n    def time_saturation_vapor_pressure_slope(self):\n        saturation_vapor_pressure_slope(self.temp)\n\n    def setup(self):\n        self.temp = np.arange(1, 101, 1)",
        "min_run_count": 2,
        "name": "bench_meteorology.Bench_saturation_vapor_pressure_slope.time_saturation_vapor_pressure_slope",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "dd42ec67e1bd2c46f72b0b460d99dfdcab789acbe6e9b917236d1c5c5219dd59",
        "warmup_time": -1
    },
    "bench_spherical.Bench_spherical.peakmem_decomposition": {
        "code": "class Bench_spherical:\n    def peakmem_decomposition(self):\n        decomposition(self.test_data, self.test_scale, self.theta_grid, self.phi_grid)\n\n    def setup(self):\n        max_harm = 23\n        num_phi = 90\n        num_theta = 180\n    \n        theta = np.linspace(0, tau - tau / num_theta, num_theta)\n        phi = np.linspace(\n            pi / (2 * num_phi),\n            pi - pi / (2 * num_phi),\n            num_phi,\n        )\n        self.theta_grid, self.phi_grid = np.meshgrid(theta, phi)\n        self.test_scale = np.sin(self.phi_grid)\n    \n        count = 0\n        primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23]\n        self.test_data = np.zeros(self.phi_grid.shape)\n        self.test_results = []\n        test_harmonics = []\n        for n in range(max_harm + 1):\n            for m in range(n + 1):\n                test_harmonics.append([n, m])\n                self.test_results.append(0)\n                if n in primes and m in primes:\n                    if m in primes[1::2]:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).imag\n                        self.test_results[-1] = 1j\n                        count += 1\n                    else:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).real\n                        self.test_results[-1] = 1\n                        count += 1",
        "name": "bench_spherical.Bench_spherical.peakmem_decomposition",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c22765cc83951fd6a2341975431ab5b4c27200b50a5710dc430a0fe5ccd98a19"
    },
    "bench_spherical.Bench_spherical.peakmem_recomposition": {
        "code": "class Bench_spherical:\n    def peakmem_recomposition(self):\n        recomposition(self.test_results, self.theta_grid, self.phi_grid)\n\n    def setup(self):\n        max_harm = 23\n        num_phi = 90\n        num_theta = 180\n    \n        theta = np.linspace(0, tau - tau / num_theta, num_theta)\n        phi = np.linspace(\n            pi / (2 * num_phi),\n            pi - pi / (2 * num_phi),\n            num_phi,\n        )\n        self.theta_grid, self.phi_grid = np.meshgrid(theta, phi)\n        self.test_scale = np.sin(self.phi_grid)\n    \n        count = 0\n        primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23]\n        self.test_data = np.zeros(self.phi_grid.shape)\n        self.test_results = []\n        test_harmonics = []\n        for n in range(max_harm + 1):\n            for m in range(n + 1):\n                test_harmonics.append([n, m])\n                self.test_results.append(0)\n                if n in primes and m in primes:\n                    if m in primes[1::2]:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).imag\n                        self.test_results[-1] = 1j\n                        count += 1\n                    else:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).real\n                        self.test_results[-1] = 1\n                        count += 1",
        "name": "bench_spherical.Bench_spherical.peakmem_recomposition",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "dcddd91b963deb0ed7de3bc51f41fc47d49b64afd9af8eb3ff09368b47378c7b"
    },
    "bench_spherical.Bench_spherical.peakmem_scale_voronoi": {
        "code": "class Bench_spherical:\n    def peakmem_scale_voronoi(self):\n        scale_voronoi(self.theta_grid, self.phi_grid)\n\n    def setup(self):\n        max_harm = 23\n        num_phi = 90\n        num_theta = 180\n    \n        theta = np.linspace(0, tau - tau / num_theta, num_theta)\n        phi = np.linspace(\n            pi / (2 * num_phi),\n            pi - pi / (2 * num_phi),\n            num_phi,\n        )\n        self.theta_grid, self.phi_grid = np.meshgrid(theta, phi)\n        self.test_scale = np.sin(self.phi_grid)\n    \n        count = 0\n        primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23]\n        self.test_data = np.zeros(self.phi_grid.shape)\n        self.test_results = []\n        test_harmonics = []\n        for n in range(max_harm + 1):\n            for m in range(n + 1):\n                test_harmonics.append([n, m])\n                self.test_results.append(0)\n                if n in primes and m in primes:\n                    if m in primes[1::2]:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).imag\n                        self.test_results[-1] = 1j\n                        count += 1\n                    else:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).real\n                        self.test_results[-1] = 1\n                        count += 1",
        "name": "bench_spherical.Bench_spherical.peakmem_scale_voronoi",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "12dde2aedf2708c21eed3eb5d0e701994599de36381ba80c903901a79ce5c314"
    },
    "bench_spherical.Bench_spherical.time_decomposition": {
        "code": "class Bench_spherical:\n    def time_decomposition(self):\n        decomposition(self.test_data, self.test_scale, self.theta_grid, self.phi_grid)\n\n    def setup(self):\n        max_harm = 23\n        num_phi = 90\n        num_theta = 180\n    \n        theta = np.linspace(0, tau - tau / num_theta, num_theta)\n        phi = np.linspace(\n            pi / (2 * num_phi),\n            pi - pi / (2 * num_phi),\n            num_phi,\n        )\n        self.theta_grid, self.phi_grid = np.meshgrid(theta, phi)\n        self.test_scale = np.sin(self.phi_grid)\n    \n        count = 0\n        primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23]\n        self.test_data = np.zeros(self.phi_grid.shape)\n        self.test_results = []\n        test_harmonics = []\n        for n in range(max_harm + 1):\n            for m in range(n + 1):\n                test_harmonics.append([n, m])\n                self.test_results.append(0)\n                if n in primes and m in primes:\n                    if m in primes[1::2]:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).imag\n                        self.test_results[-1] = 1j\n                        count += 1\n                    else:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).real\n                        self.test_results[-1] = 1\n                        count += 1",
        "min_run_count": 2,
        "name": "bench_spherical.Bench_spherical.time_decomposition",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3e5747ba253361d8fc9a96762cd871d88823373b9305c6ba60f4fe5a555ae21d",
        "warmup_time": -1
    },
    "bench_spherical.Bench_spherical.time_recomposition": {
        "code": "class Bench_spherical:\n    def time_recomposition(self):\n        recomposition(self.test_results, self.theta_grid, self.phi_grid)\n\n    def setup(self):\n        max_harm = 23\n        num_phi = 90\n        num_theta = 180\n    \n        theta = np.linspace(0, tau - tau / num_theta, num_theta)\n        phi = np.linspace(\n            pi / (2 * num_phi),\n            pi - pi / (2 * num_phi),\n            num_phi,\n        )\n        self.theta_grid, self.phi_grid = np.meshgrid(theta, phi)\n        self.test_scale = np.sin(self.phi_grid)\n    \n        count = 0\n        primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23]\n        self.test_data = np.zeros(self.phi_grid.shape)\n        self.test_results = []\n        test_harmonics = []\n        for n in range(max_harm + 1):\n            for m in range(n + 1):\n                test_harmonics.append([n, m])\n                self.test_results.append(0)\n                if n in primes and m in primes:\n                    if m in primes[1::2]:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).imag\n                        self.test_results[-1] = 1j\n                        count += 1\n                    else:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).real\n                        self.test_results[-1] = 1\n                        count += 1",
        "min_run_count": 2,
        "name": "bench_spherical.Bench_spherical.time_recomposition",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "69bb9693dcf525fa477ba6c01eccc48e543864865c9ffe7c3446451be3164c7c",
        "warmup_time": -1
    },
    "bench_spherical.Bench_spherical.time_scale_voronoi": {
        "code": "class Bench_spherical:\n    def time_scale_voronoi(self):\n        scale_voronoi(self.theta_grid, self.phi_grid)\n\n    def setup(self):\n        max_harm = 23\n        num_phi = 90\n        num_theta = 180\n    \n        theta = np.linspace(0, tau - tau / num_theta, num_theta)\n        phi = np.linspace(\n            pi / (2 * num_phi),\n            pi - pi / (2 * num_phi),\n            num_phi,\n        )\n        self.theta_grid, self.phi_grid = np.meshgrid(theta, phi)\n        self.test_scale = np.sin(self.phi_grid)\n    \n        count = 0\n        primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23]\n        self.test_data = np.zeros(self.phi_grid.shape)\n        self.test_results = []\n        test_harmonics = []\n        for n in range(max_harm + 1):\n            for m in range(n + 1):\n                test_harmonics.append([n, m])\n                self.test_results.append(0)\n                if n in primes and m in primes:\n                    if m in primes[1::2]:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).imag\n                        self.test_results[-1] = 1j\n                        count += 1\n                    else:\n                        self.test_data += sph_harm_y(\n                            n,\n                            m,\n                            self.phi_grid,\n                            self.theta_grid,\n                        ).real\n                        self.test_results[-1] = 1\n                        count += 1",
        "min_run_count": 2,
        "name": "bench_spherical.Bench_spherical.time_scale_voronoi",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6bdb5f9c9b004c678fa0722b430c3679705715c93e992717d1ca80c3391cc4f3",
        "warmup_time": -1
    },
    "bench_stats.Bench_eofunc_eofs.peakmem_eofunc": {
        "code": "class Bench_eofunc_eofs:\n    def peakmem_eofunc(self):\n        eofunc_eofs(self.sample_data_eof, neofs=1, time_dim=2)\n\n    def setup(self):\n        self.sample_data_eof = np.arange(64, dtype='int64').reshape((4, 4, 4))",
        "name": "bench_stats.Bench_eofunc_eofs.peakmem_eofunc",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c4cf60f857f25a3607ef6fa517d682ef5886c6cb05f98936833ca713c87bc68f"
    },
    "bench_stats.Bench_eofunc_eofs.time_eofunc": {
        "code": "class Bench_eofunc_eofs:\n    def time_eofunc(self):\n        eofunc_eofs(self.sample_data_eof, neofs=1, time_dim=2)\n\n    def setup(self):\n        self.sample_data_eof = np.arange(64, dtype='int64').reshape((4, 4, 4))",
        "min_run_count": 2,
        "name": "bench_stats.Bench_eofunc_eofs.time_eofunc",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "99eb5fd9b6f0b4217f31c4747e038a23a86d47e91499777ac83d753deb7a9cd6",
        "warmup_time": -1
    },
    "bench_stats.Bench_eofunc_ps.peakmem_eofunc_ps": {
        "code": "class Bench_eofunc_ps:\n    def peakmem_eofunc_ps(self):\n        eofunc_pcs(self.sst, npcs=5, meta=True)\n\n    def setup(self):\n        try:\n            self.nc_ds = xr.open_dataset(dir + \"/test/eofunc_dataset.nc\")\n        except Exception:\n            self.nc_ds = xr.open_dataset(dir + \"/../test/eofunc_dataset.nc\")\n    \n        self.sst = self.nc_ds.sst",
        "name": "bench_stats.Bench_eofunc_ps.peakmem_eofunc_ps",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "893920d7ab810dff85a84f6ec4b680dbee0b2553f50248fae77bdadb33d92a7f"
    },
    "bench_stats.Bench_eofunc_ps.time_eofunc_ps": {
        "code": "class Bench_eofunc_ps:\n    def time_eofunc_ps(self):\n        eofunc_pcs(self.sst, npcs=5, meta=True)\n\n    def setup(self):\n        try:\n            self.nc_ds = xr.open_dataset(dir + \"/test/eofunc_dataset.nc\")\n        except Exception:\n            self.nc_ds = xr.open_dataset(dir + \"/../test/eofunc_dataset.nc\")\n    \n        self.sst = self.nc_ds.sst",
        "min_run_count": 2,
        "name": "bench_stats.Bench_eofunc_ps.time_eofunc_ps",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "feee5331de56ab58f4260ca70aa6e01157843c8ab484414da282ff5c94a802fd",
        "warmup_time": -1
    },
    "bench_stats.Bench_pearson_r.time_pearson_r": {
        "code": "class Bench_pearson_r:\n    def time_pearson_r(self):\n        pearson_r(self.a, self.b, weights=self.weights)\n\n    def setup(self):\n        times = xr.date_range(\n            start='2022-08-01', end='2022-08-05', freq='D', use_cftime=True\n        )\n        lats = np.linspace(start=-45, stop=45, num=3, dtype='float32')\n        lons = np.linspace(start=-180, stop=180, num=4, dtype='float32')\n    \n        x, y, z = np.meshgrid(lons, lats, times)\n        np.random.seed(0)\n    \n        self.a = np.random.random_sample((len(lats), len(lons), len(times)))\n        self.b = np.power(self.a, 2)\n        self.weights = np.cos(np.deg2rad(y))",
        "min_run_count": 2,
        "name": "bench_stats.Bench_pearson_r.time_pearson_r",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6cd62ea3aa331a25fe69d2fb2b6b911c095cbea3100a6c7d9e6d36f9b8199449",
        "warmup_time": -1
    },
    "import.Import.timeraw_import_geocat_comp": {
        "code": "class Import:\n    def timeraw_import_geocat_comp(self):\n        return \"import geocat.comp\"",
        "min_run_count": 2,
        "name": "import.Import.timeraw_import_geocat_comp",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a31d189939828b73cd67532df40f01aebfe362b9fd831be60d8eef67ee309055",
        "warmup_time": -1
    },
    "version": 2
}